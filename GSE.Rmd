---
title: "Gene-set enrichment analysis"
author: "Oliver Hölsken"
date: "12.12.2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preparing the working environment

### Install Bioconductor

```{r}
if(!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install(version = "3.14")
```

### Install required BioConductor packages

```{r}
BiocManager::install(c('DESeq2', 'glmpca', 'EnhancedVolcano'))
```

```{r}
library(BiocManager)

library(ggplot2)
library(ggrepel)
library(genefilter)

library(dplyr)
library(tibble)
library(readr)
library(FactoMineR)
library(tidyr)
```

## Perform Differential expression analysis

### Generate a DESeq2 Data Set

```{r}
countMat <- Expression_data$countMat
ann <- Expression_data$ann
condition <- ann$condition
geneMat <- Expression_data$geneMat
```

```{r}
library(DESeq2)
```

```{r}
###### Excluding low/ none expressed genes
keep <- rowSums(countMat > 0) >= 3 

# BUILD DESEQ DATA
dds <- DESeqDataSetFromMatrix(countData = countMat[keep, ],
                              colData = ann,
                              design = ~ condition)
```

```{r}
mcols(dds) <- DataFrame(mcols(dds), geneMat[keep, ])
```

```{r}
# GET COUNT
dds <- estimateSizeFactors(dds)
dds.counts <- counts(dds, normalized=TRUE)
```

```{r}
# get normalized rlogs
rld <- rlogTransformation(dds, blind=TRUE)
rlds <- assay(rld)
```

## PCA Analyse

Dies dient der Visualisierung von Sample-Sample Abständen. Die Datenpunkte werden in einer 2D Projektion geplottet. Diese Richtungen können die Unterschiede der Proben erklären.

### GLM-PCA

Steht für generalized PCA. Das Package heißt glmpca (Twones et al. 2019). Als Input werden die counts verwendet. Es vermeidet die Probleme, die bei der Normalisierng auftreten können.

```{r}
library(glmpca)
```

```{r}
gpca <- glmpca(counts(dds), L=2)
gpca.dat <- gpca$factors
gpca.dat$condition <- dds$condition
```

```{r fig.asp = 0.5, fig.width = 12}
ggplot(gpca.dat, aes(x = dim1, y = dim2, color = condition)) +
  geom_point(size =2) + coord_fixed() + ggtitle("glmpca - Generalized PCA")
```

Die Proben des Normalgewebes (rot) unterscheiden sich voneinander auf der y-Achse (dim2). Sie unterscheiden sich vom Tumorgewebe (blau) auf der x-Achse (dim1). Eine Probe liegt in der Mitte zwischen beiden Gruppen, es gibt einen outlier bei den Tumor-Samples in dim2.

Die rlog-transformierten Daten können ebenfalls verwendet werden mittels der `plotPCA` Funktion des `FactorMineR` Package:

```{r fig.asp = 0.5, fig.width = 12}
pcaData <- plotPCA(rld, intgroup=c("condition"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=condition)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
```

## Perform differential expression analysis

```{r}
# DIFFERENTIAL ANALYSIS
dds <- DESeq(dds, test = "Wald", fitType = "mean")
result_dss = results(dds)
```

```{r}
summary(result_dss)
```

### Data Frame transformations

```{r}
#Transform results to Data-Frame
results.deseq2 <- as.data.frame(result_dss)
```

```{r}
# Apply new column "Gene" from row Names
results.deseq2$Gene <- row.names(results.deseq2)
head(results.deseq2)
```

```{r}
#Split both Values in the Gene column to "Gene_Name" and "Entrez_ID".
results.deseq2 <- separate(results.deseq2, Gene, sep = "__", into = c("Gene_Name", "Entrez_ID"))
head(results.deseq2)
```

```{r}
# set Gene_Name to first column
results.deseq2 <- results.deseq2[, c(7,8,1,2,3,4,5,6)]
head(results.deseq2)
```

```{r}
# Order results by adjusted p value
results.deseq2.tmp <- results.deseq2[!is.na(results.deseq2$padj),]
results.deseq2.sig <- results.deseq2.tmp[which(results.deseq2.tmp$padj < 0.1),]
results.deseq2.sig.sort <- results.deseq2.sig[order(results.deseq2.sig$padj, decreasing = F),]
head(results.deseq2.sig.sort)
```

Generate a xlsx file for all DEG
```{r}
library(openxlsx)
```

```{r}
#Write xlsx file
write.xlsx(results.deseq2.sig.sort, file = "KICH_NormalvsTumor_DESeq.xlsx", asTable = F, firstRow = T, headerStyle = createStyle(textDecoration = 'bold'), keepNA = F, rowNames = F, overwrite = T)
```

```{r}
# Order values by 2 FOLD change
results.deseq2.sig.up <-  results.deseq2.sig.sort[order(results.deseq2.sig.sort$log2FoldChange
, decreasing = T),]
head(results.deseq2.sig.up)
```

```{r}
tail(results.deseq2.sig.up)
```

Determine which genes are up- and down-regulated (log2FC > 2 or < -2, respectively)
```{r}
#Upregulated Genes (2 Fold Change)
results.deseq2.sig.up.2FC <- results.deseq2.sig.up[results.deseq2.sig.up$log2FoldChange > 2,]
#Downregulated Genes (-2 Fold Change)
results.deseq2.sig.down.2FC.tmp <- results.deseq2.sig.up[results.deseq2.sig.up$log2FoldChange < -2,]
results.deseq2.sig.down.2FC <- results.deseq2.sig.down.2FC.tmp[order(results.deseq2.sig.down.2FC.tmp$log2FoldChange, decreasing = F),]
```

Export results
```{r}
#Write xlsx of DEG up- and downregulated (with two sheets)
list_of_datasets <- list("upregulated" = results.deseq2.sig.up.2FC, "downregulated" = results.deseq2.sig.down.2FC)
write.xlsx(list_of_datasets, file = "KICH_NormalvsTumor_DESeq_up_down.xlsx", asTable = F, firstRow = T, headerStyle = createStyle(textDecoration = 'bold'), keepNA = F, rowNames = F, overwrite = T)
```

## Volcano Plot

### Plot basic Volcano 

This was done using the `EnhancedVolcano` Package.

```{r}
library(EnhancedVolcano)
```

```{r fig.asp = 1.2, fig.width = 12}
p <- EnhancedVolcano(results.deseq2,
    lab = results.deseq2$Gene_Name,
    title = 'Normal vs. Tumor DESeq2 results',
    subtitle = "Differential expression",
    pointSize = 2.0,
    labSize = 4.0,
    FCcutoff = 2.0,
    drawConnectors = TRUE,
    widthConnectors = 0.5,
    boxedLabels = TRUE,
    pCutoff = 10e-32,
    labFace = 'bold',
    caption = bquote(~Log[2]~ "fold change cutoff, 2; p-value cutoff, 10e-32"),
    legendPosition = "right",
    legendLabSize = 14,
    x = 'log2FoldChange',
    y = 'pvalue')
p
```


KCNU1 is highly upregulated in the Tumor samples.

## Heatmaps

### Create a list with top 20 up-and downregulated genes
```{r}
#Create date frame with significant genes (40)
total_up_down <- rbind(results.deseq2.sig.up.2FC[1:20,], results.deseq2.sig.down.2FC[1:20,])
#Add Gene column (used later to merge with count matrix)
total_up_down$Gene <- row.names(total_up_down)
total_up_down <- total_up_down %>% relocate(Gene, .before = Gene_Name)
head(total_up_down)
```

### Normalized count matrix

```{r}
# Transform count matrix to Data frame
heatmap_norm.df <- as.data.frame(dds.counts)
# Change Colum Labels
names(heatmap_norm.df) <- ann$condition
# Generate unique columnames
colnames(heatmap_norm.df) <- make.unique(names(heatmap_norm.df))
# add rownames as column
heatmap_norm.df$Gene <- row.names(heatmap_norm.df)
heatmap_norm.df <- heatmap_norm.df %>% relocate(Gene, .before = Normal)
head(heatmap_norm.df)
```

#### Merge

```{r}
# Merge total data frame and heatmap_norm.df by Gene column
data_frame_merge <- semi_join(heatmap_norm.df, total_up_down, 
                          by = 'Gene', all = F)
data_frame_merge <- data_frame_merge[-c(1)]
head(data_frame_merge)
```

#### Visualization

```{r}
library(pheatmap)
```

```{r fig.asp = 1.2, fig.width = 12}
#Convert to Matrix
data_frame_merge <- as.matrix(data_frame_merge)
#Plot
data_frame_merge %>% pheatmap(cluster_cols = F)
```

##### Log2 transformed

```{r fig.asp = 1.2, fig.width = 12}
## Log2 tranformation
heatmap_data_log2 <- data_frame_merge %>% log2()
# Check if there are any INF values adn remove them
heatmap_data_log2[is.infinite(heatmap_data_log2)] <- 0 
#Plot log2 heatmap
heatmap_data_log2 %>% pheatmap(cluster_cols = F)
```

##### Substract Mean

```{r fig.asp = 1.2, fig.width = 12}
## Substract the mean
heatmap_data_meanSubstract <- heatmap_data_log2 - rowMeans((heatmap_data_log2))
#Plot  heatmap
heatmap_data_meanSubstract %>% pheatmap(cluster_cols = F)
```

##### zScores (see also rlog transformed scaled)

```{r fig.asp = 1.2, fig.width = 12}
heatmap_data_zscores <- heatmap_data_meanSubstract/rowSds(as.matrix(heatmap_data_log2))

heatmap_data_zscores %>%
  pheatmap(cluster_cols = F)
```

### rlog transformed count matrix

Die rlog Transformation ist eine Art der Count data transformation. Ähnlich wie bei der `log2()` Funktion, werden die count Values transformiert, aber es werden keine negativen Werte ausgegeben und die Werte werden zur library size normalisiert.

> regularized logarithm or rlog, which incorporates a prior on the sample differences (Love, Huber, and Anders 2014). [...] produce transformed data on the log2 scale which has been normalized with respect to library size or other normalization factors.

Quelle: <https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#data-transformations-and-visualization>

```{r}
# Transform to count matrix to Data frame
heatmap_rlog.df <- as.data.frame(rlds)
# Change Colum Labels
names(heatmap_rlog.df) <- ann$condition
colnames(heatmap_rlog.df) <- make.unique(names(heatmap_rlog.df))
# add rownames as column
heatmap_rlog.df$Gene <- row.names(heatmap_rlog.df)
heatmap_rlog.df <- heatmap_rlog.df %>% relocate(Gene, .before = Normal)
head(heatmap_rlog.df)
```

```{r}
# Merge total data frame and heatmap_norm.df
data_frame_merge_rlog <- semi_join(heatmap_rlog.df, total_up_down, 
                          by = 'Gene', all = F)
data_frame_merge_rlog  <- data_frame_merge_rlog[-c(1)]
head(data_frame_merge_rlog)
```

##### Heatmap of rlog transformed values

```{r fig.asp = 1.2, fig.width = 12}
#Convert to Matrix
data_frame_merge_rlog <- as.matrix(data_frame_merge_rlog)
#Plot
data_frame_merge_rlog %>% pheatmap(cluster_cols = F)
```

### rlog scaled

Erzeugung einer rlog_scaled Matrix:

```{r}
data_frame_merge_rlog_scaled <- t(scale(t(data_frame_merge_rlog), center = T, scale =T))
```

Erzeugung der Heatmap

```{r fig.asp = 1.2, fig.width = 12}
data_frame_merge_rlog_scaled  %>%
  pheatmap(cluster_cols = F)
```

Scaling (oder Standardization) transformiert die Daten, der Mean/Durchschnitt wird auf 0 und die Standard-Abweichung auf 1 gesetzt. Dies entspricht den z scores. Dies eignet sich be Werten mit hoher Varianz und Extremweren, da diese sonst die Heatmap dominieren (z.B. UMOD Gen).

## Citations

```{r}
citation("DESeq2")
citation("EnhancedVolcano")
```

## Session info

```{r}
sessionInfo()
```
